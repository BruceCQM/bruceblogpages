import{_ as l,o as e,c as p,b as s,d as n,a}from"./app.fb5335e3.js";const c="/bruceblogpages/assets/split-chunks.4ff0562f.png",o="/bruceblogpages/assets/module-chunk-bundle.913ac91a.png",t="/bruceblogpages/assets/chunkId.474c3b94.png",L=JSON.parse('{"title":"webpack 深入学习","description":"","frontmatter":{},"headers":[{"level":2,"title":"webpack 与其它打包工具的不同","slug":"webpack-与其它打包工具的不同","link":"#webpack-与其它打包工具的不同","children":[]},{"level":2,"title":"webapck 工作原理","slug":"webapck-工作原理","link":"#webapck-工作原理","children":[]},{"level":2,"title":"chunk","slug":"chunk","link":"#chunk","children":[{"level":3,"title":"entry 生成 chunk","slug":"entry-生成-chunk","link":"#entry-生成-chunk","children":[]},{"level":3,"title":"按需加载（异步）产生的 chunk","slug":"按需加载-异步-产生的-chunk","link":"#按需加载-异步-产生的-chunk","children":[]},{"level":3,"title":"代码分割产生的 chunk","slug":"代码分割产生的-chunk","link":"#代码分割产生的-chunk","children":[]}]},{"level":2,"title":"bundle","slug":"bundle","link":"#bundle","children":[]},{"level":2,"title":"chunk 和 bundle 的区别","slug":"chunk-和-bundle-的区别","link":"#chunk-和-bundle-的区别","children":[]},{"level":2,"title":"filename & chunkFilename","slug":"filename-chunkfilename","link":"#filename-chunkfilename","children":[]},{"level":2,"title":"命名(hash)","slug":"命名-hash","link":"#命名-hash","children":[]},{"level":2,"title":"chunkId","slug":"chunkid","link":"#chunkid","children":[]},{"level":2,"title":"manifest","slug":"manifest","link":"#manifest","children":[]}],"relativePath":"fe/webpack/webpack_deep.md","lastUpdated":1720496202000}'),r={name:"fe/webpack/webpack_deep.md"},i=s("h1",{id:"webpack-深入学习",tabindex:"-1"},[n("webpack 深入学习 "),s("a",{class:"header-anchor",href:"#webpack-深入学习","aria-hidden":"true"},"#")],-1),u=s("h2",{id:"webpack-与其它打包工具的不同",tabindex:"-1"},[n("webpack 与其它打包工具的不同 "),s("a",{class:"header-anchor",href:"#webpack-与其它打包工具的不同","aria-hidden":"true"},"#")],-1),h=s("p",null,"在浏览器中运行 JavaScript 有两种方法。",-1),D=s("p",null,"第一种方式，引用一些脚本来存放每个功能。这种方案很难扩展，因为加载太多脚本会导致网络瓶颈。",-1),d=s("p",null,"第二种方式，使用一个包含所有项目代码的大型 js 文件，但这会导致作用域、文件大小、可读性和可维护性方面的问题。",-1),y=s("p",null,"立即调用函数表达式（IIFE）的出现解决了大型项目的作用域问题。当脚本文件被封装在 IIFE 内部时，可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。因此诞生了一批 Gulp、Grunt 等任务执行器。",-1),F=s("p",null,"但是这样修改一个文件意味着必须重新构建整个文件，拼接可以做到容易地跨文件重用脚本，但却使构建结果的优化变得更加困难。如何判断代码是否实际被使用？即使你只用到 loadash 中的某个函数，也必须在构建结果中加入整个库，接着将它们压缩到一起。如何 treeshake 代码依赖？难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。",-1),b=s("p",null,[s("a",{href:"https://webpack.docschina.org/concepts/why-webpack/",link:"card",target:"_blank",rel:"noreferrer"},"为什么选择webpack")],-1),k=a("",33),C=s("p",null,[s("a",{href:"https://juejin.cn/post/7005530386641977374",link:"card",target:"_blank",rel:"noreferrer"},"webpack 中module、chunk 、bundle 的区别")],-1),A=s("p",null,[s("a",{href:"https://blog.csdn.net/qq_17175013/article/details/119753186",link:"card",target:"_blank",rel:"noreferrer"},"webpack——module、chunk和bundle的区别")],-1),m=s("h2",{id:"filename-chunkfilename",tabindex:"-1"},[n("filename & chunkFilename "),s("a",{class:"header-anchor",href:"#filename-chunkfilename","aria-hidden":"true"},"#")],-1),_=s("p",null,"通过 output 的 filename 和 chunkFilename 控制 chunk 输出的 bundle 命名。",-1),f=s("p",null,[s("a",{href:"https://juejin.cn/post/6844904166150651917",link:"card",target:"_blank",rel:"noreferrer"},"output中chunkFilename和filename的区别")],-1),g=s("p",null,"MiniCssExtractPlugin 也同样有这些字段：",-1),w=s("p",null,[s("a",{href:"https://github.com/VenenoFSD/Learn-Webpack4/issues/17",link:"card",target:"_blank",rel:"noreferrer"},"Webpack - css 文件的代码分割")],-1),x=s("h2",{id:"命名-hash",tabindex:"-1"},[n("命名(hash) "),s("a",{class:"header-anchor",href:"#命名-hash","aria-hidden":"true"},"#")],-1),j=s("p",null,"webpack 文件打包一般有三种 hash：hash、chunkhash、contenthash。",-1),v=s("ul",null,[s("li",null,[s("p",null,"hash 是项目级别的，使用 hash 的缺点是，加入只修改了其中一个文件，但是所有文件的文件名里的 hash 都是相同的。")]),s("li",null,[s("p",null,"chunkhash 根据不同的入口文件(entry)进行依赖文件解析，构建对应的 chunk，生成对应的哈希值。")]),s("li",null,[s("p",null,"contenthash 是针对文件内容级别的，只有自己模块的内容改变，哈希值才会改变。")])],-1),E=s("p",null,[s("a",{href:"https://juejin.cn/post/6844903942384517127",link:"card",target:"_blank",rel:"noreferrer"},"从源码看webpack的hash策略")],-1),I=s("p",null,[s("a",{href:"https://juejin.cn/post/7078589390422802440",link:"card",target:"_blank",rel:"noreferrer"},"webpack中文件打包 hash、chunkhash、contenthash 的区别")],-1),S=a("",11),q=s("p",null,[s("a",{href:"https://juejin.cn/post/6844903924818771981",link:"card",target:"_blank",rel:"noreferrer"},"深入理解webpack的chunkId对线上缓存的思考")],-1),T=s("h2",{id:"manifest",tabindex:"-1"},[n("manifest "),s("a",{class:"header-anchor",href:"#manifest","aria-hidden":"true"},"#")],-1),P=s("p",null,"webpack manifest 是一个特殊的文件，它用于记录 webpack 编译后的所有资产（包括 JavaScript、css、图像等）的映射关系。这个映射关系可以帮助我们在代码中更方便地引用这些资产，并且在更新资产时，不用担心因为引用资源的路径改变导致的问题。",-1),N=s("p",null,"通常情况下，webpack manifest 会在生产构建中启用，并将其写入到磁盘的一个特定位置，以便在运行时可以快速访问。在生产环境使用 webpack manifest 可以提高应用程序的性能和可靠性。",-1),V=[i,u,h,D,d,y,F,b,k,C,A,m,_,f,g,w,x,j,v,E,I,S,q,T,P,N];function J($,z,G,B,M,R){return e(),p("div",null,V)}const O=l(r,[["render",J]]);export{L as __pageData,O as default};
