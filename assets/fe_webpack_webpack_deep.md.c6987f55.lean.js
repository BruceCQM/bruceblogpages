import{_ as l,o as e,c as p,b as s,d as n,a}from"./app.73ed221c.js";const o="/bruceblogpages/assets/split-chunks.4ff0562f.png",t="/bruceblogpages/assets/module-chunk-bundle.913ac91a.png",c="/bruceblogpages/assets/chunkId.474c3b94.png",vs=JSON.parse('{"title":"webpack 深入学习","description":"","frontmatter":{},"headers":[{"level":2,"title":"webpack 与其它打包工具的不同","slug":"webpack-与其它打包工具的不同","link":"#webpack-与其它打包工具的不同","children":[]},{"level":2,"title":"webapck 工作原理","slug":"webapck-工作原理","link":"#webapck-工作原理","children":[]},{"level":2,"title":"chunk","slug":"chunk","link":"#chunk","children":[{"level":3,"title":"entry 生成 chunk","slug":"entry-生成-chunk","link":"#entry-生成-chunk","children":[]},{"level":3,"title":"按需加载（异步）产生的 chunk","slug":"按需加载-异步-产生的-chunk","link":"#按需加载-异步-产生的-chunk","children":[]},{"level":3,"title":"代码分割产生的 chunk","slug":"代码分割产生的-chunk","link":"#代码分割产生的-chunk","children":[]}]},{"level":2,"title":"bundle","slug":"bundle","link":"#bundle","children":[]},{"level":2,"title":"chunk 和 bundle 的区别","slug":"chunk-和-bundle-的区别","link":"#chunk-和-bundle-的区别","children":[]},{"level":2,"title":"filename & chunkFilename","slug":"filename-chunkfilename","link":"#filename-chunkfilename","children":[]},{"level":2,"title":"命名(hash)","slug":"命名-hash","link":"#命名-hash","children":[]},{"level":2,"title":"chunkId","slug":"chunkid","link":"#chunkid","children":[]},{"level":2,"title":"manifest","slug":"manifest","link":"#manifest","children":[]},{"level":2,"title":"长缓存","slug":"长缓存","link":"#长缓存","children":[]},{"level":2,"title":"开发环境添加缓存","slug":"开发环境添加缓存","link":"#开发环境添加缓存","children":[]},{"level":2,"title":"打包","slug":"打包","link":"#打包","children":[{"level":3,"title":"提取公共代码","slug":"提取公共代码","link":"#提取公共代码","children":[]},{"level":3,"title":"固定 moduleId","slug":"固定-moduleid","link":"#固定-moduleid","children":[]},{"level":3,"title":"固定 chunkId","slug":"固定-chunkid","link":"#固定-chunkid","children":[]},{"level":3,"title":"contenthash","slug":"contenthash","link":"#contenthash","children":[]},{"level":3,"title":"runtime 和 manifest","slug":"runtime-和-manifest","link":"#runtime-和-manifest","children":[]}]},{"level":2,"title":"webpack VS vite","slug":"webpack-vs-vite","link":"#webpack-vs-vite","children":[{"level":3,"title":"冷启动","slug":"冷启动","link":"#冷启动","children":[]},{"level":3,"title":"热更新","slug":"热更新","link":"#热更新","children":[]},{"level":3,"title":"打包一致性","slug":"打包一致性","link":"#打包一致性","children":[]}]},{"level":2,"title":"热更新原理","slug":"热更新原理","link":"#热更新原理","children":[]},{"level":2,"title":"esbuild 为何这么快","slug":"esbuild-为何这么快","link":"#esbuild-为何这么快","children":[]},{"level":2,"title":"常用的 loader 和 plugin","slug":"常用的-loader-和-plugin","link":"#常用的-loader-和-plugin","children":[{"level":3,"title":"loader","slug":"loader","link":"#loader","children":[]},{"level":3,"title":"plugin","slug":"plugin","link":"#plugin","children":[]}]},{"level":2,"title":"Scope Hoisting","slug":"scope-hoisting","link":"#scope-hoisting","children":[{"level":3,"title":"是什么","slug":"是什么","link":"#是什么","children":[]},{"level":3,"title":"打包结果示例","slug":"打包结果示例","link":"#打包结果示例","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"自动开启","slug":"自动开启","link":"#自动开启","children":[]},{"level":3,"title":"手动开启","slug":"手动开启","link":"#手动开启","children":[]}]},{"level":2,"title":"资源管理:file-loader&url-loader","slug":"资源管理-file-loader-url-loader","link":"#资源管理-file-loader-url-loader","children":[]},{"level":2,"title":"分片、按需加载","slug":"分片、按需加载","link":"#分片、按需加载","children":[]},{"level":2,"title":"webpack 实现动态打包换肤","slug":"webpack-实现动态打包换肤","link":"#webpack-实现动态打包换肤","children":[]},{"level":2,"title":"webpack 处理 css","slug":"webpack-处理-css","link":"#webpack-处理-css","children":[]}],"relativePath":"fe/webpack/webpack_deep.md","lastUpdated":1721217546000}'),r={name:"fe/webpack/webpack_deep.md"},i=s("h1",{id:"webpack-深入学习",tabindex:"-1"},[n("webpack 深入学习 "),s("a",{class:"header-anchor",href:"#webpack-深入学习","aria-hidden":"true"},"#")],-1),D=s("h2",{id:"webpack-与其它打包工具的不同",tabindex:"-1"},[n("webpack 与其它打包工具的不同 "),s("a",{class:"header-anchor",href:"#webpack-与其它打包工具的不同","aria-hidden":"true"},"#")],-1),h=s("p",null,"在浏览器中运行 JavaScript 有两种方法。",-1),y=s("p",null,"第一种方式，引用一些脚本来存放每个功能。这种方案很难扩展，因为加载太多脚本会导致网络瓶颈。",-1),d=s("p",null,"第二种方式，使用一个包含所有项目代码的大型 js 文件，但这会导致作用域、文件大小、可读性和可维护性方面的问题。",-1),u=s("p",null,"立即调用函数表达式（IIFE）的出现解决了大型项目的作用域问题。当脚本文件被封装在 IIFE 内部时，可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。因此诞生了一批 Gulp、Grunt 等任务执行器。",-1),C=s("p",null,"但是这样修改一个文件意味着必须重新构建整个文件，拼接可以做到容易地跨文件重用脚本，但却使构建结果的优化变得更加困难。如何判断代码是否实际被使用？即使你只用到 loadash 中的某个函数，也必须在构建结果中加入整个库，接着将它们压缩到一起。如何 treeshake 代码依赖？难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。",-1),F=s("p",null,[s("a",{href:"https://webpack.docschina.org/concepts/why-webpack/",link:"static",target:"_blank",rel:"noreferrer"},"为什么选择webpack")],-1),b=a("",33),A=s("p",null,[s("a",{href:"https://juejin.cn/post/7005530386641977374",link:"static",target:"_blank",rel:"noreferrer"},"webpack 中module、chunk 、bundle 的区别")],-1),k=s("p",null,[s("a",{href:"https://blog.csdn.net/qq_17175013/article/details/119753186",link:"static",target:"_blank",rel:"noreferrer"},"webpack——module、chunk和bundle的区别")],-1),m=s("h2",{id:"filename-chunkfilename",tabindex:"-1"},[n("filename & chunkFilename "),s("a",{class:"header-anchor",href:"#filename-chunkfilename","aria-hidden":"true"},"#")],-1),_=s("p",null,"通过 output 的 filename 和 chunkFilename 控制 chunk 输出的 bundle 命名。",-1),g=s("p",null,[s("a",{href:"https://juejin.cn/post/6844904166150651917",link:"static",target:"_blank",rel:"noreferrer"},"output中chunkFilename和filename的区别")],-1),f=s("p",null,"MiniCssExtractPlugin 也同样有这些字段：",-1),w=s("p",null,[s("a",{href:"https://github.com/VenenoFSD/Learn-Webpack4/issues/17",link:"static",target:"_blank",rel:"noreferrer"},"Webpack - css 文件的代码分割")],-1),v=s("h2",{id:"命名-hash",tabindex:"-1"},[n("命名(hash) "),s("a",{class:"header-anchor",href:"#命名-hash","aria-hidden":"true"},"#")],-1),j=s("p",null,"webpack 文件打包一般有三种 hash：hash、chunkhash、contenthash。",-1),x=s("ul",null,[s("li",null,[s("p",null,"hash 是项目级别的，使用 hash 的缺点是，加入只修改了其中一个文件，但是所有文件的文件名里的 hash 都是相同的。")]),s("li",null,[s("p",null,"chunkhash 根据不同的入口文件(entry)进行依赖文件解析，构建对应的 chunk，生成对应的哈希值。")]),s("li",null,[s("p",null,"contenthash 是针对文件内容级别的，只有自己模块的内容改变，哈希值才会改变。")])],-1),E=s("p",null,[s("a",{href:"https://juejin.cn/post/6844903942384517127",link:"static",target:"_blank",rel:"noreferrer"},"从源码看webpack的hash策略")],-1),S=s("p",null,[s("a",{href:"https://juejin.cn/post/7078589390422802440",link:"static",target:"_blank",rel:"noreferrer"},"webpack中文件打包 hash、chunkhash、contenthash 的区别")],-1),T=a("",11),B=s("p",null,[s("a",{href:"https://juejin.cn/post/6844903924818771981",link:"static",target:"_blank",rel:"noreferrer"},"深入理解webpack的chunkId对线上缓存的思考")],-1),I=s("h2",{id:"manifest",tabindex:"-1"},[n("manifest "),s("a",{class:"header-anchor",href:"#manifest","aria-hidden":"true"},"#")],-1),q=s("p",null,"webpack manifest 是一个特殊的文件，它用于记录 webpack 编译后的所有资产（包括 JavaScript、css、图像等）的映射关系。这个映射关系可以帮助我们在代码中更方便地引用这些资产，并且在更新资产时，不用担心因为引用资源的路径改变导致的问题。",-1),P=s("p",null,"通常情况下，webpack manifest 会在生产构建中启用，并将其写入到磁盘的一个特定位置，以便在运行时可以快速访问。在生产环境使用 webpack manifest 可以提高应用程序的性能和可靠性。",-1),M=s("h2",{id:"长缓存",tabindex:"-1"},[n("长缓存 "),s("a",{class:"header-anchor",href:"#长缓存","aria-hidden":"true"},"#")],-1),V=s("p",null,[s("a",{href:"https://johninch.github.io/Roundtable/Question-Bank/webpack/chunkhash.html#%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9chunkhash",link:"static",target:"_blank",rel:"noreferrer"},"持久化缓存caching（注意id问题）")],-1),N=s("p",null,[s("a",{href:"https://juejin.cn/post/7136876121886785550#heading-1",link:"static",target:"_blank",rel:"noreferrer"},"持久性缓存来提高构建性能")],-1),R=s("p",null,[s("a",{href:"https://zhuanlan.zhihu.com/p/376543854",link:"static",target:"_blank",rel:"noreferrer"},"webpack缓存原理")],-1),z=s("p",null,[s("a",{href:"https://juejin.cn/post/7088552132260921352",link:"static",target:"_blank",rel:"noreferrer"},"深度解析webpack5持久化缓存")],-1),H=a("",35),J=s("p",null,[s("a",{href:"https://juejin.cn/post/7110748046853406756",link:"static",target:"_blank",rel:"noreferrer"},"一文搞懂webpack hash持久化")],-1),W=a("",13),L=s("p",null,[s("a",{href:"https://juejin.cn/post/7109475126810411044",link:"static",target:"_blank",rel:"noreferrer"},"前端工程化vite与webpack的优缺点对比")],-1),K=s("p",null,[s("a",{href:"https://juejin.cn/post/7097493230572273700#heading-26",link:"static",target:"_blank",rel:"noreferrer"},"rollup，vite以及webpack比较与介绍")],-1),O=a("",17),U=s("p",null,[s("a",{href:"https://juejin.cn/post/6844904008432222215#heading-7",link:"static",target:"_blank",rel:"noreferrer"},"轻松理解webpack热更新原理")],-1),$=s("p",null,[s("a",{href:"https://juejin.cn/post/6885348399924084744",link:"static",target:"_blank",rel:"noreferrer"},"webpack热加载的实现原理")],-1),G=s("p",null,[s("a",{href:"https://blog.csdn.net/bigname22/article/details/127362168",link:"static",target:"_blank",rel:"noreferrer"},"webpack热更新原理-连阿珍都看懂了")],-1),Q=s("h2",{id:"esbuild-为何这么快",tabindex:"-1"},[n("esbuild 为何这么快 "),s("a",{class:"header-anchor",href:"#esbuild-为何这么快","aria-hidden":"true"},"#")],-1),X=s("ol",null,[s("li",null,[s("p",null,"js 是单线程串行，esbuild 是新开一个进程，然后多线程并行，充分发挥多核优势。")]),s("li",null,[s("p",null,"go 是纯机器码，肯定要比 JIT 快。")]),s("li",null,[s("p",null,"不使用 AST，优化了构建流程。")])],-1),Y=s("p",null,[s("a",{href:"https://juejin.cn/post/7097493230572273700#heading-26",link:"static",target:"_blank",rel:"noreferrer"},"rollup，vite以及webpack比较与介绍")],-1),Z=a("",5),ss=s("p",null,[s("a",{href:"https://juejin.cn/post/6844903795512573966",link:"static",target:"_blank",rel:"noreferrer"},"使用 webpack 的各种插件提升你的开发效率")],-1),ns=a("",25),as=s("p",null,[s("a",{href:"https://juejin.cn/post/6850418110983241741",link:"static",target:"_blank",rel:"noreferrer"},"了不起的 Webpack Scope Hoisting 学习指南")],-1),ls=s("h2",{id:"资源管理-file-loader-url-loader",tabindex:"-1"},[n("资源管理:file-loader&url-loader "),s("a",{class:"header-anchor",href:"#资源管理-file-loader-url-loader","aria-hidden":"true"},"#")],-1),es=s("p",null,[s("a",{href:"https://juejin.cn/post/7000225935215558687",link:"static",target:"_blank",rel:"noreferrer"},"Webpack 中 file-loader 和 url-loader 的区别")],-1),ps=s("h2",{id:"分片、按需加载",tabindex:"-1"},[n("分片、按需加载 "),s("a",{class:"header-anchor",href:"#分片、按需加载","aria-hidden":"true"},"#")],-1),os=s("p",null,"require.ensure 或 require.include 实现依赖前置。",-1),ts=s("p",null,[s("a",{href:"https://mp.weixin.qq.com/s/MRhEJOiijLVsbHH6BoQisw",link:"static",target:"_blank",rel:"noreferrer"},"Webpack 实用技巧高效实战")],-1),cs=s("h2",{id:"webpack-实现动态打包换肤",tabindex:"-1"},[n("webpack 实现动态打包换肤 "),s("a",{class:"header-anchor",href:"#webpack-实现动态打包换肤","aria-hidden":"true"},"#")],-1),rs=s("p",null,"首次加载只引用默认主题文件，其它的可以到切换的时候再引入。",-1),is=s("p",null,"因此只需要解决编译多套 css 输出的问题，和不让 css 注入 HTML 的问题就好。",-1),Ds=s("p",null,[s("a",{href:"https://juejin.cn/post/6844903596992135182#heading-3",link:"static",target:"_blank",rel:"noreferrer"},"webpack 换肤功能多主题/配色样式打包解决方案")],-1),hs=s("p",null,[s("a",{href:"https://juejin.cn/post/7206909221806981175#heading-2",link:"static",target:"_blank",rel:"noreferrer"},"前端构建工具vite进阶系列(三) -- 静态资源与css模块化的处理")],-1),ys=s("p",null,[s("a",{href:"https://juejin.cn/post/7129128214735093791",link:"static",target:"_blank",rel:"noreferrer"},"基于 webpack 项目接入 vite 你可能需要注意的点")],-1),ds=s("h2",{id:"webpack-处理-css",tabindex:"-1"},[n("webpack 处理 css "),s("a",{class:"header-anchor",href:"#webpack-处理-css","aria-hidden":"true"},"#")],-1),us=s("p",null,"处理 css-loader 中的 @import 需要使用 importLoaders。",-1),Cs=s("p",null,[s("a",{href:"https://juejin.cn/post/7083776122587971597",link:"static",target:"_blank",rel:"noreferrer"},"如何使用webpack提取和压缩CSS并处理兼容性")],-1),Fs=[i,D,h,y,d,u,C,F,b,A,k,m,_,g,f,w,v,j,x,E,S,T,B,I,q,P,M,V,N,R,z,H,J,W,L,K,O,U,$,G,Q,X,Y,Z,ss,ns,as,ls,es,ps,os,ts,cs,rs,is,Ds,hs,ys,ds,us,Cs];function bs(As,ks,ms,_s,gs,fs){return e(),p("div",null,Fs)}const js=l(r,[["render",bs]]);export{vs as __pageData,js as default};
